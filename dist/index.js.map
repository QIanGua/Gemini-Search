{
  "version": 3,
  "sources": ["../server/env.ts", "../server/index.ts", "../server/routes.ts", "../server/vite.ts", "../vite.config.ts"],
  "sourcesContent": ["import dotenv from \"dotenv\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst envPath = path.resolve(__dirname, \"../.env\");\n\nexport function setupEnvironment() {\n  const result = dotenv.config({ path: envPath });\n  if (result.error) {\n    throw new Error(\n      `Failed to load .env file from ${envPath}: ${result.error.message}`\n    );\n  }\n\n  if (!process.env.GOOGLE_API_KEY) {\n    throw new Error(\n      \"GOOGLE_API_KEY environment variable must be set in .env file\"\n    );\n  }\n\n  return {\n    GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,\n    NODE_ENV: process.env.NODE_ENV || \"development\",\n  };\n}\n", "import { setupEnvironment } from \"./env\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport express, { type Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport { setupVite, serveStatic, log } from \"./vite\";\n\n// Setup environment variables first\nconst env = setupEnvironment();\nconsole.log(\"\\n--- Environment Setup Debug ---\");\nconsole.log(\"Environment variables loaded:\", env);\nconsole.log(\"--- End Debug ---\\n\");\n\n// Get the directory name properly with ES modules\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path = req.path;\n  let capturedJsonResponse: Record<string, any> | undefined = undefined;\n\n  const originalResJson = res.json;\n  res.json = function (bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"\u2026\";\n      }\n\n      log(logLine);\n    }\n  });\n\n  next();\n});\n\n(async () => {\n  const server = registerRoutes(app);\n\n  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n    throw err;\n  });\n\n  // importantly only setup vite in development and after\n  // setting up all the other routes so the catch-all route\n  // doesn't interfere with the other routes\n  if (app.get(\"env\") === \"development\") {\n    await setupVite(app, server);\n  } else {\n    serveStatic(app);\n  }\n\n  // ALWAYS serve the app on port 3000\n  // this serves both the API and the client\n  const PORT = 3000;\n  server.listen(PORT, \"0.0.0.0\", () => {\n    log(`serving on port ${PORT}`);\n  });\n})();\n", "import type { Express } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport {\n  GoogleGenerativeAI,\n  type ChatSession,\n  type GenerateContentResult,\n} from \"@google/generative-ai\";\nimport { marked } from \"marked\";\nimport { setupEnvironment } from \"./env\";\n\nconst env = setupEnvironment();\nconst genAI = new GoogleGenerativeAI(env.GOOGLE_API_KEY);\nconst model = genAI.getGenerativeModel({\n  model: \"gemini-2.0-flash-exp\",\n  generationConfig: {\n    temperature: 0.9,\n    topP: 1,\n    topK: 1,\n    maxOutputTokens: 2048,\n  },\n});\n\n// Store chat sessions in memory\nconst chatSessions = new Map<string, ChatSession>();\n\n// Format raw text into proper markdown\nasync function formatResponseToMarkdown(\n  text: string | Promise<string>\n): Promise<string> {\n  // Ensure we have a string to work with\n  const resolvedText = await Promise.resolve(text);\n\n  // First, ensure consistent newlines\n  let processedText = resolvedText.replace(/\\r\\n/g, \"\\n\");\n\n  // Process main sections (lines that start with word(s) followed by colon)\n  processedText = processedText.replace(\n    /^([A-Za-z][A-Za-z\\s]+):(\\s*)/gm,\n    \"## $1$2\"\n  );\n\n  // Process sub-sections (any remaining word(s) followed by colon within text)\n  processedText = processedText.replace(\n    /(?<=\\n|^)([A-Za-z][A-Za-z\\s]+):(?!\\d)/gm,\n    \"### $1\"\n  );\n\n  // Process bullet points\n  processedText = processedText.replace(/^[\u2022\u25CF\u25CB]\\s*/gm, \"* \");\n\n  // Split into paragraphs\n  const paragraphs = processedText.split(\"\\n\\n\").filter(Boolean);\n\n  // Process each paragraph\n  const formatted = paragraphs\n    .map((p) => {\n      // If it's a header or list item, preserve it\n      if (p.startsWith(\"#\") || p.startsWith(\"*\") || p.startsWith(\"-\")) {\n        return p;\n      }\n      // Add proper paragraph formatting\n      return `${p}\\n`;\n    })\n    .join(\"\\n\\n\");\n\n  // Configure marked options for better header rendering\n  marked.setOptions({\n    gfm: true,\n    breaks: true,\n  });\n\n  // Convert markdown to HTML using marked\n  return marked.parse(formatted);\n}\n\ninterface WebSource {\n  uri: string;\n  title: string;\n}\n\ninterface GroundingChunk {\n  web?: WebSource;\n}\n\ninterface TextSegment {\n  startIndex: number;\n  endIndex: number;\n  text: string;\n}\n\ninterface GroundingSupport {\n  segment: TextSegment;\n  groundingChunkIndices: number[];\n  confidenceScores: number[];\n}\n\ninterface GroundingMetadata {\n  groundingChunks: GroundingChunk[];\n  groundingSupports: GroundingSupport[];\n  searchEntryPoint?: any;\n  webSearchQueries?: string[];\n}\n\nexport function registerRoutes(app: Express): Server {\n  // Search endpoint - creates a new chat session\n  app.get(\"/api/search\", async (req, res) => {\n    try {\n      const query = req.query.q as string;\n\n      if (!query) {\n        return res.status(400).json({\n          message: \"Query parameter 'q' is required\",\n        });\n      }\n\n      // Create a new chat session with search capability\n      const chat = model.startChat({\n        tools: [\n          {\n            // @ts-ignore - google_search is a valid tool but not typed in the SDK yet\n            google_search: {},\n          },\n        ],\n      });\n\n      // Generate content with search tool\n      const result = await chat.sendMessage(query);\n      const response = await result.response;\n      console.log(\n        \"Raw Google API Response:\",\n        JSON.stringify(\n          {\n            text: response.text(),\n            candidates: response.candidates,\n            groundingMetadata: response.candidates?.[0]?.groundingMetadata,\n          },\n          null,\n          2\n        )\n      );\n      const text = response.text();\n\n      // Format the response text to proper markdown/HTML\n      const formattedText = await formatResponseToMarkdown(text);\n\n      // Extract sources from grounding metadata\n      const sourceMap = new Map<\n        string,\n        { title: string; url: string; snippet: string }\n      >();\n\n      // Get grounding metadata from response\n      const metadata = response.candidates?.[0]?.groundingMetadata as any;\n      if (metadata) {\n        const chunks = metadata.groundingChunks || [];\n        const supports = metadata.groundingSupports || [];\n\n        chunks.forEach((chunk: any, index: number) => {\n          if (chunk.web?.uri && chunk.web?.title) {\n            const url = chunk.web.uri;\n            if (!sourceMap.has(url)) {\n              // Find snippets that reference this chunk\n              const snippets = supports\n                .filter((support: any) =>\n                  support.groundingChunkIndices.includes(index)\n                )\n                .map((support: any) => support.segment.text)\n                .join(\" \");\n\n              sourceMap.set(url, {\n                title: chunk.web.title,\n                url: url,\n                snippet: snippets || \"\",\n              });\n            }\n          }\n        });\n      }\n\n      const sources = Array.from(sourceMap.values());\n\n      // Generate a session ID and store the chat\n      const sessionId = Math.random().toString(36).substring(7);\n      chatSessions.set(sessionId, chat);\n\n      res.json({\n        sessionId,\n        summary: formattedText,\n        sources,\n      });\n    } catch (error: any) {\n      console.error(\"Search error:\", error);\n      res.status(500).json({\n        message:\n          error.message || \"An error occurred while processing your search\",\n      });\n    }\n  });\n\n  // Follow-up endpoint - continues existing chat session\n  app.post(\"/api/follow-up\", async (req, res) => {\n    try {\n      const { sessionId, query } = req.body;\n\n      if (!sessionId || !query) {\n        return res.status(400).json({\n          message: \"Both sessionId and query are required\",\n        });\n      }\n\n      const chat = chatSessions.get(sessionId);\n      if (!chat) {\n        return res.status(404).json({\n          message: \"Chat session not found\",\n        });\n      }\n\n      // Send follow-up message in existing chat\n      const result = await chat.sendMessage(query);\n      const response = await result.response;\n      console.log(\n        \"Raw Google API Follow-up Response:\",\n        JSON.stringify(\n          {\n            text: response.text(),\n            candidates: response.candidates,\n            groundingMetadata: response.candidates?.[0]?.groundingMetadata,\n          },\n          null,\n          2\n        )\n      );\n      const text = response.text();\n\n      // Format the response text to proper markdown/HTML\n      const formattedText = await formatResponseToMarkdown(text);\n\n      // Extract sources from grounding metadata\n      const sourceMap = new Map<\n        string,\n        { title: string; url: string; snippet: string }\n      >();\n\n      // Get grounding metadata from response\n      const metadata = response.candidates?.[0]?.groundingMetadata as any;\n      if (metadata) {\n        const chunks = metadata.groundingChunks || [];\n        const supports = metadata.groundingSupports || [];\n\n        chunks.forEach((chunk: any, index: number) => {\n          if (chunk.web?.uri && chunk.web?.title) {\n            const url = chunk.web.uri;\n            if (!sourceMap.has(url)) {\n              // Find snippets that reference this chunk\n              const snippets = supports\n                .filter((support: any) =>\n                  support.groundingChunkIndices.includes(index)\n                )\n                .map((support: any) => support.segment.text)\n                .join(\" \");\n\n              sourceMap.set(url, {\n                title: chunk.web.title,\n                url: url,\n                snippet: snippets || \"\",\n              });\n            }\n          }\n        });\n      }\n\n      const sources = Array.from(sourceMap.values());\n\n      res.json({\n        summary: formattedText,\n        sources,\n      });\n    } catch (error: any) {\n      console.error(\"Follow-up error:\", error);\n      res.status(500).json({\n        message:\n          error.message ||\n          \"An error occurred while processing your follow-up question\",\n      });\n    }\n  });\n\n  const httpServer = createServer(app);\n  return httpServer;\n}\n", "import express, { type Express } from \"express\";\nimport fs from \"fs\";\nimport path, { dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nimport { type Server } from \"http\";\nimport viteConfig from \"../vite.config\";\n\nconst viteLogger = createLogger();\n\nexport function log(message: string, source = \"express\") {\n  const formattedTime = new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true,\n  });\n\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\n\nexport async function setupVite(app: Express, server: Server) {\n  const vite = await createViteServer({\n    ...viteConfig,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        if (\n          msg.includes(\"[TypeScript] Found 0 errors. Watching for file changes\")\n        ) {\n          log(\"no errors found\", \"tsc\");\n          return;\n        }\n\n        if (msg.includes(\"[TypeScript] \")) {\n          const [errors, summary] = msg.split(\"[TypeScript] \", 2);\n          log(`${summary} ${errors}\\u001b[0m`, \"tsc\");\n          return;\n        } else {\n          viteLogger.error(msg, options);\n          process.exit(1);\n        }\n      },\n    },\n    server: {\n      middlewareMode: true,\n      hmr: { server },\n    },\n    appType: \"custom\",\n  });\n\n  app.use(vite.middlewares);\n  app.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n\n    try {\n      const clientTemplate = path.resolve(\n        __dirname,\n        \"..\",\n        \"client\",\n        \"index.html\",\n      );\n\n      // always reload the index.html file from disk incase it changes\n      const template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e as Error);\n      next(e);\n    }\n  });\n}\n\nexport function serveStatic(app: Express) {\n  const distPath = path.resolve(__dirname, \"public\");\n\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`,\n    );\n  }\n\n  app.use(express.static(distPath));\n\n  // fall through to index.html if the file doesn't exist\n  app.use(\"*\", (_req, res) => {\n    res.sendFile(path.resolve(distPath, \"index.html\"));\n  });\n}\n", "import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport themePlugin from \"@replit/vite-plugin-shadcn-theme-json\";\nimport path, { dirname } from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\nimport { fileURLToPath } from \"url\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nexport default defineConfig({\n  plugins: [react(), runtimeErrorOverlay(), themePlugin()],\n  resolve: {\n    alias: {\n      \"@db\": path.resolve(__dirname, \"db\"),\n      \"@\": path.resolve(__dirname, \"client\", \"src\"),\n    },\n  },\n  root: path.resolve(__dirname, \"client\"),\n  build: {\n    outDir: path.resolve(__dirname, \"dist/public\"),\n    emptyOutDir: true,\n  },\n});\n"],
  "mappings": "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",
  "names": ["dotenv", "path", "fileURLToPath", "__filename", "__dirname", "envPath", "setupEnvironment", "result", "path", "fileURLToPath", "express", "createServer", "GoogleGenerativeAI", "marked", "env", "setupEnvironment", "genAI", "GoogleGenerativeAI", "model", "chatSessions", "formatResponseToMarkdown", "text", "processedText", "formatted", "p", "marked", "registerRoutes", "app", "req", "res", "query", "chat", "response", "formattedText", "sourceMap", "metadata", "chunks", "supports", "chunk", "index", "url", "snippets", "support", "sources", "sessionId", "error", "createServer", "express", "fs", "path", "dirname", "fileURLToPath", "createViteServer", "createLogger", "defineConfig", "react", "themePlugin", "path", "dirname", "runtimeErrorOverlay", "fileURLToPath", "__filename", "__dirname", "vite_config_default", "__filename", "fileURLToPath", "__dirname", "dirname", "viteLogger", "createLogger", "log", "message", "source", "formattedTime", "setupVite", "app", "server", "vite", "createViteServer", "vite_config_default", "msg", "options", "errors", "summary", "req", "res", "next", "url", "clientTemplate", "path", "template", "fs", "page", "e", "serveStatic", "distPath", "express", "_req", "env", "setupEnvironment", "__filename", "fileURLToPath", "__dirname", "path", "app", "express", "req", "res", "next", "start", "capturedJsonResponse", "originalResJson", "bodyJson", "args", "duration", "logLine", "log", "server", "registerRoutes", "err", "_req", "_next", "status", "message", "setupVite", "serveStatic", "PORT"]
}
